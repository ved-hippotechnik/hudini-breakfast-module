package api

import (
	"net/http"
	"strconv"
	"time"

	"hudini-breakfast-module/internal/models"
	"hudini-breakfast-module/internal/services"

	"github.com/gin-gonic/gin"
)

type BreakfastHandler struct {
	breakfastService *services.BreakfastService
}

func NewBreakfastHandler(breakfastService *services.BreakfastService) *BreakfastHandler {
	return &BreakfastHandler{
		breakfastService: breakfastService,
	}
}

// GET /api/menu
func (h *BreakfastHandler) GetMenu(c *gin.Context) {
	menuItems, err := h.breakfastService.GetMenuItems()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	
	c.JSON(http.StatusOK, gin.H{"menu_items": menuItems})
}

// GET /api/menu/:id
func (h *BreakfastHandler) GetMenuItem(c *gin.Context) {
	id, err := strconv.ParseUint(c.Param("id"), 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid menu item ID"})
		return
	}
	
	menuItem, err := h.breakfastService.GetMenuItemByID(uint(id))
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Menu item not found"})
		return
	}
	
	c.JSON(http.StatusOK, gin.H{"menu_item": menuItem})
}

// POST /api/menu (Admin only)
func (h *BreakfastHandler) CreateMenuItem(c *gin.Context) {
	var menuItem models.BreakfastMenu
	if err := c.ShouldBindJSON(&menuItem); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	
	if err := h.breakfastService.CreateMenuItemWithNutrition(&menuItem); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	
	c.JSON(http.StatusCreated, gin.H{"message": "Menu item created successfully", "menu_item": menuItem})
}

// POST /api/orders
func (h *BreakfastHandler) CreateOrder(c *gin.Context) {
	var order models.BreakfastOrder
	if err := c.ShouldBindJSON(&order); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	
	// Get user ID from JWT token (would be set by auth middleware)
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}
	
	order.UserID = userID.(uint)
	
	if err := h.breakfastService.CreateOrder(&order); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	
	c.JSON(http.StatusCreated, gin.H{"message": "Order created successfully", "order": order})
}

// GET /api/orders
func (h *BreakfastHandler) GetUserOrders(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}
	
	orders, err := h.breakfastService.GetOrdersByUserID(userID.(uint))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	
	c.JSON(http.StatusOK, gin.H{"orders": orders})
}

// GET /api/orders/:id
func (h *BreakfastHandler) GetOrder(c *gin.Context) {
	id, err := strconv.ParseUint(c.Param("id"), 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid order ID"})
		return
	}
	
	order, err := h.breakfastService.GetOrderByID(uint(id))
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Order not found"})
		return
	}
	
	// Check if user owns this order or is admin
	userID, _ := c.Get("user_id")
	userRole, _ := c.Get("user_role")
	if order.UserID != userID.(uint) && userRole != "admin" && userRole != "staff" {
		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
		return
	}
	
	c.JSON(http.StatusOK, gin.H{"order": order})
}

// PUT /api/orders/:id/status (Staff/Admin only)
func (h *BreakfastHandler) UpdateOrderStatus(c *gin.Context) {
	id, err := strconv.ParseUint(c.Param("id"), 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid order ID"})
		return
	}
	
	var req struct {
		Status string `json:"status" binding:"required"`
	}
	
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	
	if err := h.breakfastService.UpdateOrderStatus(uint(id), req.Status); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	
	c.JSON(http.StatusOK, gin.H{"message": "Order status updated successfully"})
}

// GET /api/orders/:id/ohip-status
func (h *BreakfastHandler) GetOHIPStatus(c *gin.Context) {
	id, err := strconv.ParseUint(c.Param("id"), 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid order ID"})
		return
	}
	
	transaction, err := h.breakfastService.GetOHIPTransactionStatus(uint(id))
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "OHIP transaction not found"})
		return
	}
	
	c.JSON(http.StatusOK, gin.H{"ohip_transaction": transaction})
}

// GET /api/analytics
func (h *BreakfastHandler) GetAnalytics(c *gin.Context) {
	userID, _ := c.Get("user_id")
	userRole, _ := c.Get("user_role")
	
	var targetUserID uint
	if userRole == "admin" || userRole == "staff" {
		// Staff/Admin can view all analytics or specific user
		if id := c.Query("user_id"); id != "" {
			if parsedID, err := strconv.ParseUint(id, 10, 32); err == nil {
				targetUserID = uint(parsedID)
			}
		}
	} else {
		// Regular users can only see their own analytics
		targetUserID = userID.(uint)
	}
	
	// Parse date range
	startDate := time.Now().AddDate(0, -1, 0) // Default: last month
	endDate := time.Now()
	
	if start := c.Query("start_date"); start != "" {
		if parsed, err := time.Parse("2006-01-02", start); err == nil {
			startDate = parsed
		}
	}
	
	if end := c.Query("end_date"); end != "" {
		if parsed, err := time.Parse("2006-01-02", end); err == nil {
			endDate = parsed
		}
	}
	
	analytics, err := h.breakfastService.GetOrderAnalytics(targetUserID, startDate, endDate)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	
	c.JSON(http.StatusOK, gin.H{"analytics": analytics})
}
